<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>[Reactor] 3文档翻译</title><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=Edge，chrome=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="young"><link rel="short icon" href="/images/favicon.png"><link rel="icon" href="/images/favicon.png"><!--[if lt IE 9]>
<script src="/js/modernizr.js"></script>
<![endif]-->
<link rel="stylesheet" href="/css/iconfont.css">

<link rel="stylesheet" href="/css/index.css?v=202004251605.css">
<link rel="stylesheet" href="/css/info.css?v=202004251605.css">
<link href="https://cdn.bootcss.com/highlight.js/9.15.9/styles/github.min.css" rel="stylesheet"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Young" type="application/atom+xml">
</head><body><header id="header" class="header-navigation"><nav><div class="logo"><a href="http://yoursite.com">Young</a></div><h2 id="mnavh"><span class="navicon"></span></h2><ul id="starlist"><li><a href="/">首页</a></li><li><a href="/time.html">时间轴</a></li></ul><div class="searchbox"><div id="search_bar" class="search_bar"><input id="keyboard" placeholder="想搜点什么呢.." type="text" name="keyboard" autocomplete="off" class="input"><p class="search_ico"><span></span></p></div></div></nav></header><article><main><div class="con_warp"><div class="infosbox"><div class="newsview"><h3 class="news_title">[Reactor] 3文档翻译</h3><div class="bloginfo"><ul><li class="author">作者：<a href="/">young</a></li><li class="lmname"><a href="/">Reactor</a></li><li class="timer">时间：2020-04-15 16:47:07</li><li class="view"><span id="busuanzi_value_page_pv">99</span><span>次访问</span></li></ul></div><div class="tags"><a href="/tags/Reactor%E6%96%87%E6%A1%A3/" target="_blank">Reactor文档</a></div><div class="news_con"><h3 id="3-反应式编程简介"><a href="#3-反应式编程简介" class="headerlink" title="3.反应式编程简介"></a>3.反应式编程简介</h3><p>Reactor是Reactive Programming范式的实现，可以总结如下:</p>
<pre><code>反应式编程是一种异步编程范式，它涉及数据流和变化的传播。这意味着可以通过采用的编程语言轻松地表达静态（例如数组）或动态（例如事件发射器）数据流。More info: [wikipedia](https://en.wikipedia.org/wiki/Reactive_programming)</code></pre><p>作为响应式编程方向上的第一步，Microsoft在.NET生态系统中创建了响应式扩展（Rx）库。然后RxJava在JVM上实现了反应式编程。随着时间的流逝，通过Reactive Streams的努力出现了Java的规范，该规范定义了JVM上的响应库的一组接口和交互规则。它的接口已在Flow类下集成到Java 9中。</p>
<p>反应式编程范例通常以面向对象的语言表示，作为Observer设计模式的扩展。 您还可以将主要的反应流模式与熟悉的Iterator设计模式进行比较，因为所有这些库中的Iterable-Iterator对都有双重性。一个主要的区别是，虽然Iterator是基于pull的，但是反应流却是基于push的。</p>
<p>使用迭代器是命令式编程模式，即使访问值的方法仅由Iterable负责。 确实，开发人员可以选择何时访问序列中的next（）项。在反应式流中，上述对等效于Publisher-Subscriber。 但是是发布者在新可用值出现时通知订阅者，而此推送方面是做出反应的关键。同样，应用于推入值的操作以声明方式而不是命令方式表示：程序员表示计算的逻辑，而不是描述其确切的控制流程。</p>
<p>除了推送值之外，还以明确定义的方式涵盖了错误处理和完成方面。 发布者可以将新值推送到其订阅者（通过调用onNext），但也可以发出错误信号（通过调用onError）或完成（通过调用onComplete）。 错误和完成都会终止序列。 可以总结如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onNext x 0..N [onError | onComplete]</span><br></pre></td></tr></table></figure>

<p>这种方法非常灵活。该模式支持没有值，一个值或n个值（包括无限个值序列，例如时钟的连续滴答声）的用例。</p>
<h3 id="但是为什么我们首先需要这样的异步反应式库？"><a href="#但是为什么我们首先需要这样的异步反应式库？" class="headerlink" title="但是为什么我们首先需要这样的异步反应式库？"></a>但是为什么我们首先需要这样的异步反应式库？</h3><h4 id="Blocking-Can-Be-Wasteful"><a href="#Blocking-Can-Be-Wasteful" class="headerlink" title="Blocking Can Be Wasteful"></a>Blocking Can Be Wasteful</h4><p>现代应用程序可以吸引大量的并发用户，即使现代硬件的功能不断提高，现代软件的性能仍然是关键问题。广义上讲，有两种方法可以提高程序的性能：</p>
<pre><code>1.并行使用更多线程和更多硬件资源
2.在使用现有资源方面寻求更高的效率</code></pre><p>通常，Java开发人员通过使用阻塞代码来编写程序。除非存在性能瓶颈，否则这种做法很好。然后是时候引入其他线程，运行类似的阻塞代码了。但是这种资源利用的扩展会迅速引入竞争和并发问题。更糟糕的是，阻塞会浪费资源。 如果仔细观察，程序一旦遇到一些延迟（特别是I/O，例如数据库请求或网络调用），就会浪费资源，因为线程（可能有很多线程）现在处于空闲状态，等待数据。</p>
<p>因此，并行化方法不是灵丹妙药。 有必要访问硬件的全部功能，但是推理和资源浪费也很复杂。</p>
<h4 id="Asynchronicity-to-the-Rescue"><a href="#Asynchronicity-to-the-Rescue" class="headerlink" title="Asynchronicity to the Rescue?"></a>Asynchronicity to the Rescue?</h4><p>前面提到的第二种方法，寻求更高的效率，可以解决资源浪费的问题。 通过编写异步的非阻塞代码，<br>您可以将执行切换到使用相同基础资源的另一个活动任务，并在异步处理完成后返回到当前进程。</p>
<p>但是如何在JVM上生成异步代码？ Java提供了两种异步编程模型：<br>    * Callbacks：异步方法没有返回值，但是带有一个额外的回调参数（lambda或匿名类），该参数在结果可用时被调用。一个著名的例子是Swing的EventListener层次结构。<br>    * Futures：异步方法立即返回Future <T>。 异步过程计算T值，但是Future对象包装对其的访问。该值不是立即可用的，并且可以轮询该对象，直到该值可用为止。 例如，运行Callable <T>任务的ExecutorService使用Future对象。</p>
<p>这些技术够好吗？ 并非针对每个用例，这两种方法都有局限性。<br>回调很难组合在一起，迅速导致难以阅读和维护的代码（称为“回调地狱”）。</p>
<p>考虑一个示例：在用户界面上显示用户的前五个收藏夹，如果没有收藏夹则显示建议。<br>这需要三项服务（一项提供喜欢的ID，第二项获取喜欢的详细信息，第三项提供带有详细信息的建议），<br>如下所示：<br>例子5.回调地狱的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">userService.getFavorites(userId, <span class="keyword">new</span> Callback&lt;List&lt;String&gt;&gt;() &#123;   <span class="comment">//1 </span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123; <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123; <span class="comment">//3</span></span><br><span class="line">          suggestionService.getSuggestions(<span class="keyword">new</span> Callback&lt;List&lt;Favorite&gt;&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(List&lt;Favorite&gt; list)</span> </span>&#123; <span class="comment">//4</span></span><br><span class="line">              UiUtils.submitOnUiThread(() -&gt; &#123;  <span class="comment">//5</span></span><br><span class="line">                list.stream()</span><br><span class="line">                    .limit(<span class="number">5</span>)</span><br><span class="line">                    .forEach(uiList::show); <span class="comment">//6</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123; <span class="comment">//7</span></span><br><span class="line">              UiUtils.errorPopup(error);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          list.stream()  <span class="comment">//8</span></span><br><span class="line">              .limit(<span class="number">5</span>)</span><br><span class="line">              .forEach(favId -&gt; favoriteService.getDetails(favId, <span class="comment">//9</span></span><br><span class="line">                <span class="keyword">new</span> Callback&lt;Favorite&gt;() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Favorite details)</span> </span>&#123;</span><br><span class="line">                    UiUtils.submitOnUiThread(() -&gt; uiList.show(details));</span><br><span class="line">                  &#125;</span><br><span class="line">    </span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">                    UiUtils.errorPopup(error);</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              ));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">        UiUtils.errorPopup(error);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<pre><code>1.我们有基于回调的服务：一种回调接口，其中的一种方法在异步过程成功时被调用，而在发生错误时被调用。
2.第一个服务使用收藏夹ID列表调用其回调。
3.如果该列表为空，则必须转到RecommendationionService。
4.RecommendationionService将List &lt;Favorite&gt;提供给第二个回调。
5.由于我们处理的是UI，因此我们需要确保使用的代码在UI线程中运行。
6.我们使用Java 8 Stream将处理的建议数限制为五个，并在UI的图形列表中显示它们。
7.在每个级别，我们以相同的方式处理错误：在弹出窗口中显示它们。
8.返回收藏夹ID级别。 如果该服务返回了完整列表，则需要转到favoriteService获取详细的Favorite对象。 
    由于我们只需要五个，因此我们首先传输ID列表以将其限制为五个。
9.再一次，回调。 这次，我们得到了一个完整的“收藏夹”对象，该对象被推送到UI线程中的UI。</code></pre><p>那是很多代码，很难遵循并且包含重复的部分。 考虑它在Reactor中的等效功能:<br>示例6.与回调代码等效的Reactor代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">userService.getFavorites(userId) <span class="comment">//1</span></span><br><span class="line">               .flatMap(favoriteService::getDetails) <span class="comment">//2</span></span><br><span class="line">               .switchIfEmpty(suggestionService.getSuggestions()) <span class="comment">//3</span></span><br><span class="line">               .take(<span class="number">5</span>) <span class="comment">//4</span></span><br><span class="line">               .publishOn(UiUtils.uiThreadScheduler()) <span class="comment">//5</span></span><br><span class="line">               .subscribe(uiList::show, UiUtils::errorPopup); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<pre><code>1.我们从收藏夹ID的流开始。
2.我们将它们异步转换为详细的收藏夹对象（flatMap）。 现在，我们有一个收藏夹流。
3.如果“收藏夹”的流为空，则可以通过RecommendationionService切换到后备。
4.我们最多只对结果流中的五个元素感兴趣。
5.最后，我们要处理UI线程中的每个数据。
6.我们通过描述如何处理数据的最终形式（在UI列表中显示）以及发生错误的情况(显示弹出窗口)来触发流程。</code></pre><p>如果要确保在少于800毫秒的时间内检索喜欢的ID，或者如果花费更长的时间从缓存中获取它们，该怎么办？ 在基于回调的代码中，这是一项复杂的任务。在Reactor中，就像在链中添加超时操作符一样容易，如下所示：<br>例子7.具有超时和回退的Reactor代码的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">userService.getFavorites(userId)</span><br><span class="line">                .timeout(Duration.ofMillis(<span class="number">800</span>)) <span class="comment">//1</span></span><br><span class="line">                .onErrorResume(cacheService.cachedFavoritesFor(userId)) <span class="comment">//2</span></span><br><span class="line">                .flatMap(favoriteService::getDetails) <span class="comment">//3</span></span><br><span class="line">                .switchIfEmpty(suggestionService.getSuggestions())</span><br><span class="line">                .take(<span class="number">5</span>)</span><br><span class="line">                .publishOn(UiUtils.uiThreadScheduler())</span><br><span class="line">                .subscribe(uiList::show, UiUtils::errorPopup);</span><br></pre></td></tr></table></figure>
<pre><code>1.如果以上部分的发射时间超过800ms，则传播错误
2.如果发生错误，请退回到cacheService。
3.链的其余部分与前面的示例相似。</code></pre><p>Future比回调要好一些，但是尽管CompletableFuture对Java8进行了改进，但它们在组合方面仍然表现不佳。一起编排多个Future对象是可行的，但并不容易。 另外，未来还有其他问题：</p>
<pre><code>1.通过调用get（）方法很容易以Future对象结束另一个阻塞情况。
2.它们不支持惰性计算。
3.他们缺乏对多个值和高级错误处理的支持。</code></pre><p>再看一个例子：我们得到一个ID列表，我们要从中获取一个名称和一个统计信息，并将它们成对组合，所有这些信息都是异步的。下面的示例使用CompletableFuture类型的列表来执行此操作<br>Example 8. Example of CompletableFuture combination</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); <span class="comment">//1</span></span><br><span class="line">     </span><br><span class="line">     CompletableFuture&lt;List&lt;String&gt;&gt; result = ids.thenComposeAsync(l -&gt; &#123; <span class="comment">//2</span></span><br><span class="line">        Stream&lt;CompletableFuture&lt;String&gt;&gt; zip = <span class="comment">//3</span></span><br><span class="line">                l.stream().map(i -&gt; &#123;  </span><br><span class="line">                    CompletableFuture&lt;S tring&gt; n ameTask = ifhName(i);  <span class="comment">//4 </span></span><br><span class="line">                    CompletableFuture&lt;Integer&gt; statTask = ifhStat(i);   <span class="comment">//5</span></span><br><span class="line">     </span><br><span class="line">                    <span class="keyword">return</span> nameTask.thenCombineAsync(statTask, (name, stat) -&gt; <span class="string">"Name "</span> + name + <span class="string">" has stats "</span> + stat); <span class="comment">//6 </span></span><br><span class="line">                &#125;);</span><br><span class="line">        List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList());  <span class="comment">//7</span></span><br><span class="line">        CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(<span class="keyword">new</span> CompletableFuture[combinationList.size()]);</span><br><span class="line">     </span><br><span class="line">        CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); <span class="comment">//8</span></span><br><span class="line">        <span class="keyword">return</span> allDone.thenApply(v -&gt; combinationList.stream() </span><br><span class="line">                .map(CompletableFuture::join) <span class="comment">//9</span></span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line">     &#125;);</span><br><span class="line"> </span><br><span class="line">     List&lt;String&gt; results = result.join();  <span class="comment">//10</span></span><br><span class="line">     assertThat(results).contains(</span><br><span class="line">            <span class="string">"Name NameJoe has stats 103"</span>,</span><br><span class="line">            <span class="string">"Name NameBart has stats 104"</span>,</span><br><span class="line">            <span class="string">"Name NameHenry has stats 105"</span>,</span><br><span class="line">            <span class="string">"Name NameNicole has stats 106"</span>,</span><br><span class="line">            <span class="string">"Name NameABSLAJNFOAJNFOANFANSF has stats 121"</span>);</span><br></pre></td></tr></table></figure>
<pre><code>1.我们从一个可以为我们提供ID值列表的future开始。
2.一旦获得列表，我们想开始更深层次的异步处理。
3.对于列表中的每个元素：
4.异步获取关联名称。
5.异步获取关联的任务。
6.合并两个结果。
7.现在，我们有了代表所有组合任务的期货清单。 要执行这些任务，我们需要将列表转换为数组。
8.将数组传递给CompletableFuture.allOf，该数组将输出一个Future，当所有任务完成时，该Future将完成。
9.棘手的一点是allOf返回CompletableFuture &lt;Void&gt;，因此我们在future列表上重申，使用join（）收集其结果（此处不会阻塞，因为allOf确保future全部完成了）。 
10.一旦整个异步管道被触发，我们等待它被处理并返回可以声明的结果列表。</code></pre><p>由于Reactor提供了更多组合运算符，因此可以简化此过程，如下所示：<br>例9.与以后的代码等效的Reactor代码的示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; ids = ifhrIds(); <span class="comment">//1</span></span><br><span class="line">     </span><br><span class="line">      Flux&lt;String&gt; combinations =</span><br><span class="line">            ids.flatMap(id -&gt; &#123;  <span class="comment">//2</span></span><br><span class="line">                Mono&lt;String&gt; nameTask = ifhrName(id); <span class="comment">//3</span></span><br><span class="line">                Mono&lt;Integer&gt; statTask = ifhrStat(id); <span class="comment">//4</span></span><br><span class="line">      </span><br><span class="line">                <span class="keyword">return</span> nameTask.zipWith(statTask, <span class="comment">//5</span></span><br><span class="line">                        (name, stat) -&gt; <span class="string">"Name "</span> + name + <span class="string">" has stats "</span> + stat);</span><br><span class="line">            &#125;);</span><br><span class="line">      </span><br><span class="line">      Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); <span class="comment">//6 </span></span><br><span class="line">      </span><br><span class="line">      List&lt;String&gt; results = result.block();  <span class="comment">//7</span></span><br><span class="line">      assertThat(results).containsExactly( <span class="comment">//8</span></span><br><span class="line">            <span class="string">"Name NameJoe has stats 103"</span>,</span><br><span class="line">            <span class="string">"Name NameBart has stats 104"</span>,</span><br><span class="line">            <span class="string">"Name NameHenry has stats 105"</span>,</span><br><span class="line">            <span class="string">"Name NameNicole has stats 106"</span>,</span><br><span class="line">            <span class="string">"Name NameABSLAJNFOAJNFOANFANSF has stats 121"</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure>

<pre><code>1.这次，我们从异步提供的ID序列（Flux &lt;String&gt;）开始。
2.对于序列中的每个元素，我们都会异步处理它两次（在函数flatMap调用内部）。
3.获取关联的名称。
4.获取相关的统计信息。
5.异步组合两个值。
6.在值可用时将其汇总到一个列表中。
7.在生产中，我们将通过进一步组合或订阅它来继续异步使用Flux。 最有可能的是，我们将返回结果Mono。由于我们正在测试中，因此我们改为阻塞，等待处理完成，然后直接返回汇总的值列表。
8.断言结果。</code></pre><p>使用回调和Future对象的风险是相似的，这是发布者对订阅者对响应式编程的解决。</p>
<h4 id="From-Imperative-to-Reactive-Programming-从命令式编程到反应式编程"><a href="#From-Imperative-to-Reactive-Programming-从命令式编程到反应式编程" class="headerlink" title="From Imperative to Reactive Programming(从命令式编程到反应式编程)"></a>From Imperative to Reactive Programming(从命令式编程到反应式编程)</h4><p>反应性库（例如Reactor）旨在解决JVM上“经典”异步方法的这些缺点，同时还着重于其他一些方面：</p>
<pre><code>1.可组合性和可读性
2.以丰富的运算符词汇操纵数据流
3.订阅之前没有任何反应
4.背压或消费者向生产者发出排放速率过高信号的能力
5.High level but high value abstraction that is concurrency-agnostic(并发不可知的高级但高价值的抽象)</code></pre><h5 id="Composability-and-Readability-可组合性和可读性"><a href="#Composability-and-Readability-可组合性和可读性" class="headerlink" title="Composability and Readability(可组合性和可读性)"></a>Composability and Readability(可组合性和可读性)</h5><p>所谓“可组合性”，是指协调多个异步任务的能力，其中我们使用先前任务的结果将输入反馈给后续任务。另外，我们可以以fork-join样式运行多个任务。此外，我们可以将异步任务重用为更高级别系统中的离散组件。编排任务的能力与代码的可读性和可维护性紧密相关。随着异步处理层的数量和复杂性的增加，能够编写和读取代码变得越来越困难。如我们所见，回调模型很简单，但是它的主要缺点之一是，对于复杂的流程，您需要从一个回调中执行一个回调，该回调本身嵌套在另一个回调中，依此类推。这种混乱被称为“回调地狱”。 您可以猜测（或从经验中学到），很难找到这样的代码并进行推理。<br>Reactor提供了丰富的组合选项，其中代码反映了抽象过程的组织，并且通常将所有内容保持在同一级别（将嵌套最小化）。</p>
<h5 id="The-Assembly-Line-Analogy-流水线类比"><a href="#The-Assembly-Line-Analogy-流水线类比" class="headerlink" title="The Assembly Line Analogy 流水线类比"></a>The Assembly Line Analogy 流水线类比</h5><p> You can think of data processed by a reactive application as moving through an assembly line. Reactor is both the conveyor belt and the workstations. The raw material pours from a source (the original Publisher) and ends up as a finished product ready to be pushed to the consumer (or Subscriber).<br> 您可以将反应式应用程序处理的数据视为流水线。 Reactor既是传送带又是工作站。原材料从来源（原始发布者）倾泻而出，最终成为准备好推向消费者（或订阅者）的成品。<br>The raw material can go through various transformations and other intermediary steps or be part of a larger assembly line that aggregates intermediate pieces together. If there is a glitch or clogging at one point (perhaps boxing the products takes a disproportionately long time), the afflicted workstation can signal upstream to limit the flow of raw material.<br>原材料可以经过各种转换和其他中间步骤，也可以成为将中间件聚集在一起的较大装配线的一部分。如果某一点出现故障或堵塞（也许装箱产品花费的时间过长），那么受灾的工作站可以向上游发出信号，以限制原材料的流动。</p>
<h5 id="Operators-运算符"><a href="#Operators-运算符" class="headerlink" title="Operators 运算符"></a>Operators 运算符</h5><p>In Reactor, operators are the workstations in our assembly analogy. Each operator adds behavior to a Publisher and wraps the previous step’s Publisher into a new instance. The whole chain is thus linked, such that data originates from the first Publisher and moves down the chain, transformed by each link.<br>Eventually, a Subscriber finishes the process. Remember that nothing happens until a Subscriber subscribes to a Publisher,as we see shortly.</p>
<p> 在Reactor中，operators是我们装配类比中的工作站。每个operators都会向Publisher添加行为，并将上一步的发布服务器包装到新实例中。 因此，整个链被链接在一起，这样数据就从第一个Publisher发出并在链中向下移动，并由每个链接转换。 最终，订阅者完成了该过程。请记住，在订阅者订阅发布者之前，什么也不会发生，正如我们不久将看到的那样。</p>
<pre><code>Understanding that operators create new instances can help you avoid a common mistake that would lead you to believe that an operator you used in your chain is not being applied. See this item in the FAQ.
了解operators会创建新的实例可以帮助您避免一个常见错误，该错误会导致您认为未应用您在链中使用的运算符。 请参阅常见问题解答中的此项。</code></pre><p>While the Reactive Streams specification does not specify operators at all,one of the best added values of reactive libraries,such as Reactor, is the rich vocabulary of operators that they provide.These cover a lot of ground, from simple transformation and filtering to complex orchestration and error handling.<br>虽然反应式流规范根本没有指定运算符，但是反应式库的最佳附加值之一（例如Reactor）是它们提供的运算符的丰富词汇表。 从简单的转换和过滤到复杂的编排和错误处理，这些内容涉及很多领域。</p>
<h5 id="Nothing-Happens-Until-You-subscribe"><a href="#Nothing-Happens-Until-You-subscribe" class="headerlink" title="Nothing Happens Until You subscribe()"></a>Nothing Happens Until You subscribe()</h5><p>In Reactor, when you write a Publisher chain, data does not start pumping into it by default. Instead, you create an abstract description of your asynchronous process (which can help with reusability and composition).<br>在Reactor中，当您编写发布者链时，默认情况下不会开始将数据泵入其中。相反，您可以创建异步过程的抽象描述（这有助于重用和组合）。</p>
<p>By the act of subscribing, you tie the Publisher to a Subscriber, which triggers the flow of data in the whole chain. This is achieved internally by a single request signal from the Subscriber that is propagated upstream, all the way back to the source Publisher.<br>通过订阅，您将发布者与订阅者绑定在一起，从而触发了整个链中的数据流。 这是通过来自订阅服务器的单个请求信号在内部实现的，该请求信号向上游传播，一直返回到源发布服务器。</p>
<h5 id="Backpressure"><a href="#Backpressure" class="headerlink" title="Backpressure"></a>Backpressure</h5><p>Propagating signals upstream is also used to implement backpressure, which we described in the assembly line analogy as a feedback signal sent up the line when a workstation processes more slowly than an upstream workstation.<br>上游传播的信号也用于实现背压，我们在组装流水线中将其描述为当工作站的处理速度比上游工作站慢时，沿生产线向上发送的反馈信号。</p>
<p>The real mechanism defined by the Reactive Streams specification is pretty close to the analogy: A subscriber can work in unbounded mode and let the source push all the data at its fastest achievable rate or it can use the request mechanism to signal the source that it is ready to process at most n elements.<br>Reactive Streams规范定义的实际机制与类推非常接近：订户可以以无界模式工作，并让源以最快可达到的速率推送所有数据，或者可以使用请求机制向源发出信号，告知它 准备处理最多n个元素。</p>
<p>Intermediate operators can also change the request in-transit. Imagine a buffer operator that groups elements in batches of ten.If the subscriber requests one buffer, it is acceptable for the source to produce ten elements. Some operators also implement prefetching strategies, which avoid request(1) round-trips and is beneficial if producing the elements before they are requested is not too costly.<br>中间的operators还可以在途中更改请求。想象一下一个缓冲运算符，它将元素以十个为一组进行分组。如果subscriber请求一个缓冲区，则源产生十个元素是可以接受的。一些运算符还实现了预取策略，避免了request（1）往返，如果在请求之前生成元素的成本不太高的话，这将是有益的。</p>
<p>This transforms the push model into a push-pull hybrid, where the downstream can pull n elements from upstream if they are readily available. But if the elements are not ready,they get pushed by the upstream whenever they are produced.<br>这将推模型转换为推挽混合模型，如果容易获得，则下游可以从上游拉取n个元素。但是，如果元素尚未准备就绪，则每当它们被生产时就会被上游推送。</p>
<h5 id="Hot-vs-Cold"><a href="#Hot-vs-Cold" class="headerlink" title="Hot vs Cold"></a>Hot vs Cold</h5><p>The Rx family of reactive libraries distinguishes two broad categories of reactive sequences: hot and cold.This distinction mainly has to do with how the reactive stream reacts to subscribers:<br>Rx反应库的家族将反应序列分为两大类：热和冷。 这种区别主要与反应流对订阅者的反应有关：</p>
<p>A Cold sequence starts anew for each Subscriber, including at the source of data. For example, if the source wraps an HTTP call, a new HTTP request is made for each subscription.<br>对于每个订阅者，包括在数据源处，冷序列都会重新开始。例如，如果源包装了一个HTTP调用，则会为每个订阅发出一个新的HTTP请求。</p>
<p>A Hot sequence does not start from scratch for each Subscriber. Rather, late subscribers receive signals emitted after they subscribed. Note, however, that some hot reactive streams can cache or replay the history of emissions totally or partially. From a general perspective, a hot sequence can even emit when no subscriber is listening (an exception to the “nothing happens before you subscribe” rule).<br>并非每个订阅者都可以从头开始热序列。 相反，后订阅的订阅者会在订阅后接收发射的信号。但是请注意，某些热反应流可以全部或部分缓存或重放排放历史。从一般的角度来看，即使没有订阅者在收听，热序列甚至会发出（“订阅之前什么也没有发生”规则的例外）。</p>
<p>For more information on hot vs cold in the context of Reactor, see this reactor-specific section.</p>
<h3 id="4-Reactor-Core-Features"><a href="#4-Reactor-Core-Features" class="headerlink" title="4.Reactor Core Features"></a>4.Reactor Core Features</h3><p>Reactor项目的核心是reactor-core，一个响应式依赖库，符合Reactor streams规范，并且针对java8<br>Reactor引入了可组合的反应类型，这些类型实现了Publisher，但也提供了丰富的operators:Flux和Mono。一个Flux对象代表一个0..的反应序列。一个Mono对象表示一个单值或空(0..1)结果。</p>
<p>这种区别在类型中包含了一些语义信息，表明了异步处理的粗略基数。例如，一个HTTP请求仅产生一个响应，因此进行计数操作没有多大意义。 因此，将HTTP调用的结果表示为Mono <HttpResponse>比将其表示为Flux <HttpResponse>更有意义，因为它仅提供与零项或一个项的上下文相关的运算符。</p>
<p>更改处理的最大基数的操作符也会切换到相关类型。例如，count操作符存在于Flux中，但是它返回一个Mono<Long>。</p>
<h5 id="Flux-an-Asynchronous-Sequence-of-0-N-Items"><a href="#Flux-an-Asynchronous-Sequence-of-0-N-Items" class="headerlink" title="Flux, an Asynchronous Sequence of 0-N Items"></a>Flux, an Asynchronous Sequence of 0-N Items</h5><p>The following image shows how a Flux transforms items:<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/flux.png" alt="alt flux"></p>
<p>Flux<T>是标准的Publisher<T>它表示0到N个发射项目的异步序列，可以选择由完成信号或错误终止。 就像在Reactive Streams规范中一样，这三种信号转换为对下游订阅者的onNext，onComplete和onError方法的调用。</p>
<p>在可能的信号范围如此之大的情况下，Flux是通用的响应的类型。 请注意，所有事件，甚至是终止事件，都是可选的：没有onNext事件，但onComplete事件表示一个空的有限序列，但是删除onComplete则有一个无限的空序列（除了取消测试外，它没有什么用处）。同样，无限序列不一定为空。例如，Flux.interval（Duration）产生Flux <Long>，它是无限的并从时钟发出规则的滴答声。</p>
<h5 id="Mono-an-Asynchronous-0-1-Result"><a href="#Mono-an-Asynchronous-0-1-Result" class="headerlink" title="Mono, an Asynchronous 0-1 Result"></a>Mono, an Asynchronous 0-1 Result</h5><p>The following image shows how a Flux transforms items:<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/flux.png" alt="alt flux"></p>
<p>Mono<T>是特别的Publisher<T>，它最多发出一项，然后（可选）以onComplete信号或onError信号终止。</p>
<h4 id="原文地址：https-projectreactor-io-docs-core-release-reference-index-html-intro-reactive"><a href="#原文地址：https-projectreactor-io-docs-core-release-reference-index-html-intro-reactive" class="headerlink" title="原文地址：https://projectreactor.io/docs/core/release/reference/index.html#intro-reactive"></a>原文地址：<a href="https://projectreactor.io/docs/core/release/reference/index.html#intro-reactive" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/index.html#intro-reactive</a></h4></div></div><div class="nextinfo"><p>上一篇：<a href="/2020/04/15/%5BReactor%5DFlux-demo/">[Reactor] 反应式Flux demo</a></p><p>下一篇：<a href="/2020/04/15/Hexo%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/">Hex博客快速上手</a></p></div><div class="news_pl"><div id="comment_container"></div></div></div></div></main><aside class="r_box"><div class="card box"><h2>我的名片</h2><div class="box_con"><p>网名：young </p>
<p>职业：软件工程师</p>
<p>Email：sun_zhongy@163.com</p>
</div></div><div class="category box"><h2>文章分类</h2><div class="box_con"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Reactor/">Reactor</a><span class="category-list-count">3</span></li></ul></div></div></aside></article><footer><section class="footer_bottom"><div class="footer_container"><p class="copyright">Design by
<a href='https://tianhui.xin' target='_blank'>怪咖晨</a>
京ICP备16046477号-1
</p><ul class="social_network"></ul></div></section></footer><div class="cd-top"><i class="iconfont icon-top"></i></div>
<script src="/js/jquery.min.js"></script>
<script src="/js/scrollreveal.js"></script>
<script src="/js/hc-sticky.js"></script>
<script src="/js/canvas-nest.js" type="text/javascript" color="47,135,193" opacity="0.7" zIndex="-2" count="199"></script><script src="https://cdn.bootcss.com/highlight.js/9.15.9/highlight.min.js"></script><script src="https://cdn.bootcss.com/highlight.js/9.15.9/languages/java.min.js"></script><script src="https://cdn.bootcss.com/highlight.js/9.15.9/languages/javascript.min.js"></script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="/js/common.js?v=202004251605.js"></script>
<script src="/js/index.js?v=202004251605.js"></script>
</body></html>